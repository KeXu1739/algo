from algoHelper import *


def sortedDictFunctionality():
    sorted_dict = SortedDict({1: 1, 2: 2, 4: 3})
    # key值最小的记录
    print(sorted_dict.peekitem(0))

    # key值最大的记录
    print(sorted_dict.peekitem())

    # 比目标值小的最大的key
    target = 3
    if target not in sorted_dict:
        print(sorted_dict.peekitem(sorted_dict.bisect_left(target) - 1))
    else:
        print(sorted_dict.peekitem(sorted_dict.bisect_left(target)))
    
    # 比目标值大的最小的key
    if target not in sorted_dict:
        print(sorted_dict.peekitem(sorted_dict.bisect(target)))
    else:
        print(sorted_dict.peekitem(sorted_dict.bisect(target) - 1))
    
    # 根据key起止大小拿到一堆value，返回一个list
    start = 1
    end = 3
    print(sorted_dict.items()[start:end + 1])

    # initialize new dict based on a range of old dict
    sorted_dict2 = SortedDict(sorted_dict.items()[start:end + 1])
    
    # 根据key的范围删掉值
    print(sorted_dict)
    iterator = sorted_dict.irange(start, end)
    keys = list(iterator)
    for key in keys:
        del sorted_dict[key]
    print(sorted_dict)


def getResultsIPOBids(bids, totalShares):
    # Write your code here

    bids = sorted(bids, key=lambda x: (-x[2],x[3]), reverse=False)
    print(bids)
    print(totalShares)
    current_id = 0
    reach_end = False

    for id_, bid in enumerate(bids):
        current_id = id_
        if totalShares < 0:
            break
        else:
            totalShares -= bid[1]
            if id_ == len(bids) - 1:
                reach_end = True

    if reach_end:
        return []
    else:
        return sorted([item[0] for item in bids[current_id:]])


def addToArrayForm(num, k):
    """
    :type num: List[int]
    :type k: int
    :rtype: List[int]
    """
    n = len(num)
    i = -1
    while k % 10 != 0:
        num_add = k % 10
        if num_add + num[i] < 10:
            num[i] += num_add
        else:
            if i == -n:
                num.insert(0, 1)
                num[i] = (num[i] + num_add) % 10
            else:
                num[i] = (num[i] + num_add) % 10
                num[i-1] += 1
        k = k // 10
        i -= 1
    return num


def _1pt3acres():
    # 审题时需要注意的问题：
    # * input/output type.
    # * input size 以及edge cases of null or empty
    # * input element 有无重复
    # * input element的范围
    #  * 数字的话： 全是正数或者全是负数 或者返回必须正数或负数
    #  * string的话：是不是都是English letters (A-Z)，有没有特殊符号，有的话，会有哪些会出现
    # * 能不能改input (1D/2D array比较常见）
    # * 时间空间复杂度要求
    #  * 需不需要in place
    # * 特殊情况的处理， 找没找到的时候返回什么
    # brute force是O(N)时间复杂度的， 优化只能是LOG(N)
    # * 一般是binary search
    #  * 对于Java或者C， 注意 start+end可能会overflow 需要用start + (end - start) // 2
    #  * 一般是mid和target比较 或者和mid+-1比较或者与start/end比较
    #  * 避免死循环用 (start + 1) < end
    # * 类似于binary search的剪枝
    # * exponential backoff [我理解为数据流问题二分法找上界]
    # tree的题可以考虑：
    # * BSF/DFS
    # * DFS: pre-order, in-order, post-order
    # * BFS: level order traverse
    # * divide & conquer （无脑看左右子树 然后再考虑最后的结果）
    #  * top down - recursive
    #  * bottom up - iterative
    # * 给node编号， 第N层可以2^(n-1)个node
    # * 空间优化（知道就行）：Morris遍历: iterative approach to leverage preorder traversal that the the entire left subtree would be placed between the node and its right subtree.
    # BST 考虑利用
    # * BST中序遍历值产生的array是单调的
    # * 左子树 < ROOT < 右子树 （某些可能有等于）， 向下DFS的时候，记得更新MIN和MAX
    # BFS/DFS traverse
    # * 求最短或者最少XX 一般是用BFS，比如最短路径
    #  * use BFS for unweighted graphs and use Dijkstra's algorithm for weighted graphs
    #  * dijkstra 和普通图的不同之处在于，每个edge有weight，可以用min/max heap来找下一个node
    #       * 使用Dijkstra's algorithm 的隐含条件是图的weight是正数. 如果为负，需要用另一个算法，不需要掌握
    # * 需要记住哪些已经visited过了
    #  * 用set, boolean list, map
    #  * 用特殊符号， 比如*
    #  * 用特殊正数负数 或者（-num）或者0
    # * Backtracking with DFS.--
    #  * 进入下一层之前，update/add path/dict或者Mark visited，下一层返回之后，需要backtrack之前的update或者用remove或者unmark visited
    # * DFS traverse的时候来计算结果， 如果出现重复计算某一个，可以加入memoization来加速
    # * 如果深度太长，不推荐用DFS recursive approach， 因为会stack overflow
    # * Traverse不止可以从source出发，也可以从destination反向出发找source， reverse DFS/BFS 以及bidirectional BFS
    # array
    # * prefix sum很多时候都会用到，以及prefix sum - target有无出现和出现的次数
    # * 类似于prefix sum的还有prefix product,但是计算product时，需要注意有0
    # * 注意subsequence和subarray的相同和区别之处
    #  * 相同：不能改变element order，所以都不能sort
    #  * 不同：subsequence可以不连续，subarray必须是连续的一段
    # * 去重
    #  * 一般是用set或者map
    #  * 或者sort，然后看前后是不是一样，一样的话 就skip
    # * min/max记得考虑local min/max 和 global min/max 以及与当前num的比较
    #  * 尤其是找相乘的product的时候，negative*negative=positive. Χ
    # * 找MIN的时候 初始化成最大，一般是 float('inf') 或者0 (全是正数)
    # * 找MAX的时候 初始化成最小，一般是float('-inf') 或者0 (全是正数)
    # * min/max 还可以用heap
    # * 滑动窗口只能在array元素全为正时使用, 如果有负数那么需要dp
    # * intervals: sort by start or end, 有无overlap 看是否 current start > last end
    # * 如果找下一个小的或者大的，考虑能不能用mono stack [https://www.jianshu.com/p/7fea0b9a8960]
    # * 需要O(1) delete操作的时候，如果不需要保持原有的顺序，可以把最后一个element copy到要删除的地方， 然后删掉最后一个element.
    # stack & queue.
    # * stack: LIFO
    #  * DFS iterative
    #  * inorder/pre order/post order traverse iterative https://leetcode.com/problems/bi ... ersal-ways-for-each   
    # * queue: FIFO
    #     * BFS iterative, sometimes needs to keep track of the count as well
    # * pop前注意检查是不是空的
    # heap (priority queue)
    # * 找最大或者最小
    # * 找第K大或者第K小，或者前K大、小
    # * 用tuple时会先按照顺序比较，如果第一个元素相同，会比较第二个元素，如果第二个元素是特殊的object比如linked list node
    #  * 可以在node里面加入比较function
    #  * 可以在tuple中加入一个不重要的但是有顺序的数，比如index作为第二个数，这样能避免比较第三个node object
    # string
    # * 大部分是two pointer， 部分是DP或者DFS
    # * palindrome
    #  * 可以考虑reverse string来比较
    #  * 找palindrome可以expand from center，或者DP
    # * 用特殊符号的时候，不要用-， 以防是数字转换过来的，负数也带-
    # int
    # * 注意越界问题
    #  * 可以用long或者double.
    #  * start + (end - start) /2 而不是 (start + end) / 2.0
    #  * num1 / 2.0 + num2 / 2.0 而不是 (num1 + num2) / 2.0
    #  * 或者是 用 % 来表示results
    # DP
    # * 两个strings是要建立二维数组，然后用来减少重复计算
    #  * 一般用length+1 考虑前i个的结果
    # * 从i到i+1的时候， 状态转换要考虑清楚， 主要看怎么可以利用之前计算的结果
    # * 有的时候可能DP不是最后的结果，还需要用min/max/sum(dp)
    # * 空间优化一般是
    #  * 1D的需要记住前面的几个结果
    #  * 2D的需要记住前面的ROW的结果， 也就是滚动数组
    # linked list
    # * 快慢指针同时挪，或者先挪一个指针
    # * 有必要的时候 可以reverse linked list， 比如palindrome可以考虑reverse linked list来比较.
    # * head可能变化的时候，创建一个dummy，返回 dummy.next
    # * 快慢指针如果都从head开始，要注意下面的情况，可以考虑fast从 head.next开始
    #  * 只有两个数的时候，会不会出现死循环
    #  * 偶数的时候，mid需要找靠左边的那个还是靠右边的那个
    # * 需要同时update prev and next的时候，用doubly linked list
    #  * 大部分也可以用ordered dict解决
    # ..
    # 其他模板背诵 （按可能的常见度排序）：.
    # * quick select、sort
    #  * 一般用于解决第K或者前K的问题
    #  * in place的， 不需要额外空间.
    #  * 不稳定， average O(NLOGN) 最好O(1) 最差O(N^2)
    # * merge sort
    #  * divide & conquer: top down & bottom up
    #  * min/max heap
    # * topological sort/order.
    #  * 一般用于解决有方向的图，non-directed graph不能用， 需要用下面的union find 或者普通的DFS/BFS
    #  * 有向图看有没有cycle可以用 *A directed graph has a topological order iff it is acylic*
    # * union find
    #  * 某些题可以用DFS/BFS
    #  * DFS, BFS可能会有找不到某些点，只能用union find
    # * trie
    # * mono stack/queue
    #  * *单调递增栈可以找到元素向左遍历第一个比它小的元素: 递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理*
    #  * *单调递减栈可以找到元素向左遍历第一个比它大的元素: 维护递减的顺序，当遇到大于栈顶元素的数开始处理*
    # * 时间线的题可以用sweep line +1 -1， 然后sort by 时间去找答案. 1point 3 acres
    # * Bit manipulation using n&1 and (n>>=1) or bin(int). From 1point 3acres bbs
    # * segment tree （最后没时间，我自己没看）
    # * binary index tree （最后没时间，我自己没看
    pass


# Basics from bilibili
def note():
    ########################################### python ################################################################
    # collections.Counter 可以数出一个list里面每个元素出现了几次，直接返回一个有更多功能的字典
    ############################################ 今天的日常任务 ##########################################################
    # n维数组和一维数组下标转换 m 行 n 列 -> arr[i] -> matrix[i // n， i - n * (i // n)]
    # 坐标只和列数有关和行数无关
    # 动态规划经典题目
    ############################################ 老师的github ###########################################################
    # 包含课程中的java源码, 把??代替为课程的数字编号
    # https://github.com/algorithmzuo/algorithmbasic2020/tree/master/src/class??
    ############################################ 位运算 #################################################################
    # XOR运算，位运算相同返回0，不同返回1,或理解成无进位相加 a ^ 0 = a, a ^ a = 0, ^ 满足交换律和结合律
    # 两个无符号整型a和b，不用任何比较判断，返回较大的数，利用位运算求符号，然后利用乘法和加法求返回拿个值
    # 判断32位正数是不是2的幂和4的幂：2的幂，2进制只有最高位是1其余是0，4的幂，2进制只有最高为且为偶数位是1其余是0
    # 两个有符号32位整数a和b，不用算数运算符实现加减乘除运算,去algo helper里看一下
    ################################ 排序 ##############################################################################
    # 小和问题，逆序对问题 -> 融合排序的变体, 一段分两段递归的做法相同，不同在合并的过程
    # 荷兰国旗问题: 根据一个pivot值，把数组分成从左往右小于等于大于pivot的三部分, a sub-problem for quick sort
    # heap relation: parent at i, left child at 2 * i + 1, right child at 2 * i + 2, child at i parent at int((i - 1)/2)
    # sort almost sorted array: use a min-heap
    # 排序稳定性: 指排完序之后，如果原数组有两个元素相同，排完序之后这两个数的相对顺序不改变:
    # insert, bubble, merge(care about edge condition: if equal how to swap, how to merge): 稳定;
    # quick sort: 不稳定，利用荷兰国旗问题互换元素所以会改变顺序
    # heap sort: 不稳定, 创heap的时候顺序会被打乱（或者说heap不在乎相等element的顺序）
    # count/radix sort: 稳定, the order of numbers to pull out from bucket is kept
    # hashset, hashtable: 永远有key，区别是有没有value， 增删改查 复杂度 O(1), 但是认为这个常数时间常数项比较大（大于数组查找）,python里
    # bulletin里的dict和set都是利用hash的
    # treeset, treemap: key有序，可比大小，增删改查复杂度O(logN), python里 import sortedcontainers
    ################################ 链表 ##############################################################################
    # 反转链表:prev, curr, next， curr.next = prev, next = curr, curr = prev
    # * 试验一下快慢指针遍历数组找中点的边界条件（快指针一次走两步，慢指针一次走一步，快指针走到头， 慢指针到中点） <- Done
    # 链表中快慢指针定制写法：
    # 1. 奇数个:快走完时慢走到唯一中点, 偶数个：快走完时慢走到中点前一个
    # slow_start=head, fast=head
    # fast=fast.next.next if has next next else stop; slow = slow.next if fast goes, 快指针先判断先走,走不了了break
    # 2. 奇数个:快走完时慢走到唯一中点, 偶数个：快走完时慢走到中点后一个， 慢指针先走，走完快指针判断, 快指针走不了了break
    # slow_start=head, fast=head
    # slow = slow.next； fast=fast.next.next if has next next, fast=fast.next if has next, else stop
    # leetcode 160 -> 寻找不同长度链表的相同部分
    # 判断链表是否为回文结构 <- o(1)/o(n) space done, leetcode 234
    # 链表partition leetcode 86（给一个值，链表小于这个值的放左边，等于放中间，大于放右边）,创六个变量表示小等大区域的头和尾，然后打乱原来链
    # 表的指针指向，这个题的边界条件很神奇要自己写一下
    # leetcode 138,复制带有随机节点的链表 o(n) s, o(n) t, and * o(1) s, o(n) t,这个思路比较神奇一定要写一下
    # <- o(n) done, o(1) 重听一下有点忘了
    # 新节点串在老节点下一个，一对一对遍历，* 新节点->rand = 原节点->rand->next, 最后遍历一遍把新老链表分开
    # （原来老节点的next指向下一个老节点，原来新节点的next指向下一个新节点）
    # 查一个链表有无环，有的话返回第一个入环节点，否则返回None -> leetcode 142，<- o(n) done, o(1): 快慢指针，两个指针相交时，快指针回到头，
    # 两指针从此开始一次走一步，相交时为入环节点 <- o(1) done
    # 查两个链表（可能有环）是否相交，返回相交的第一个节点：使用有无环查找的code分别过一遍两个链表，返回两个链表各自第一个入环节点，然后讨论，一共
    # （考虑有无环，有无相交）有四种情况 (找找是不是leetcode原题目:leetcode 160 为无环简易版，完成了空间o(n)与o(1))
    ################################ 二叉树 ############################################################################
    # 递归序：按照根左右不断遍历二叉树形成的顺序，画个树自己走一遍就懂了，每一个node会被走过三次，在不同时机打印就是前中后序遍历
    # 前中后序遍历的非递归写法 -> leetcode 144, 94, 145, 前中后序遍历本质是深度优先搜索，基础数据结构需要一个栈
    # 前: 打印顺序：头左右，压栈顺序：头，pop 头，右左，弹出时打印
    # 后：打印顺序：左右头，需要两个栈，第一个栈按头，pop头，左右的方式压栈，弹出进入后一个栈，后一个栈栈内顺序为头右左，等后一个栈满了弹出并打印
    # 最终顺序为左右头
    # 中：打印顺序：左头右，压栈顺序：有左就左,从当前根节点出发的所有左节点全进去，pop并打印，pop的时候如果当前点有右节点，打印右节点，并以右节点
    # 为根，有左就左压栈重复这个过程
    # 二叉树DFS: 先序遍历
    # 二叉树BFS: 层序遍历，头左右，使用队列。每一层处理完之后队列里是下一层的节点数
    # leetcode 102, 此题可以衍生出求二叉树最大宽度（即每层最多有多少个非空的node），只需要多加一个变量记录全局最大的宽度
    # 判断 二叉树为：
    # 搜索树 leetcode98: 中序遍历每个元素不降序，则为搜索二叉树; 利用中序遍历的思想和一个全局变量来记录目前为止左边的值, 每个点需要保证左边为
    # inorder左边最后一个value小于当前node value, 然后右树inorder
    # 完全二叉树 leetcode 958：BFS为主体，其中要查两个条件: 1).如果任何一个节点有右child没有左child,return false
    # 2). 1)的情况下， 如果遇到第一个节点左右child不全，后续的节点都必须是叶节点, 上述两个条件有一个违反了就返回false,否则就是完全的
    # 满树：除了叶节点，每个节点都有两个child,一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;
    # 它的叶子数是： 2^h, 第k层的结点数是： 2^(k-1), 总结点数是： 2^k-1 (2的k次方减一), 总节点数一定是奇数。
    # 平衡二叉树 leetcode 110, 每一个递归需要左右树信息为：是否平衡和树的高度， 判断当前左右树高度差是否小于等于1，
    # 这个问题写的时候构造一个自定义数据结构同时返回前面需要的两条信息， 否则的话需要递归两次会非常慢 ->递归做都挺简单的，看下有没有非递归的解法
    # 同样的方法也可以套在判断搜索树的题目以及很多题目，称为树形dp套路
    # lowest common ancestor最低的公共祖先节点 leetcode 236 方法一：先把每个节点遍历，做一个每个节点->自己父节点的map，
    # 然后从p,q两个节点分别利用父节点map回溯，找到相交的node; 方法二：大类情况一共两种， 两个节点互为公共祖先 -> 返回靠近根部的节点就行，
    # 或两个节点不互为公共祖先，向左右孩子要节点，这样一定能找到某一个节点左孩子返回p，右孩子返回q，这时返回这个节点。。
    # inorder successor: 后继节点问题， leetcode 285，第一种方法：中序遍历产生一个列，然后找list中目标点的下一个点，即为后继节点，同理可找
    # 前驱节点； leetcode 510, 第二种方法：在有parent指针的情况下，如果当前节点有右child，则右child最左端为后继节点，如果没有右child，
    # 找parent节点，若当前节点为parent节点的右child，则继续向上，否则parent节点即为后继节点
    # 二叉树序列化和反序列化 leetcode 297,序列化就是遍历，反序列化是根据遍历顺序，碰到空停止当前branch开始建立下一个branch
    # 折纸问题：总root为0，每个左子树root均为0，每个右子树均为1的满二叉树，从上到下打印即为中序遍历打印，最节省空间的方法：不需要额外的结构存树，
    # 边创边打印即可
    ######################################## 图 #######################################################################
    # 存储方式：adjacency list/adjacency matrix，需要熟练默写:1.图，边，节点的类定义，以及如何根据各种input来构造图本身
    # 邻接表：一个链表储存所有顶点，每个顶点有个指针指向从他自己出发一步可以到达的所有顶点(即描述了出度)，无向图即双向图
    # 邻接矩阵：一个列表和一个矩阵，列表里是所有顶点的值，矩阵行代表出发点，列代表终点，值代表从出发点到终点的边的权重，0为无边（或可以自定义None
    # 为无边）
    # 顶点，边，入度，出度
    # 手写一个万能数据结构来处理图算法
    # 日常手写：bfs, dfs
    # 拓扑排序 leetcode 207（有先修课要求的选课）：编译的包依赖，抽象成有向图从而决定编译顺序，找入度为0的点，这个是最先编译的，
    # 删掉这个点和从这个点出发的所有边，找下一个入度为0的点
    # kruskal算法，适用于无向图，生成最小生成树；根据weight由小到大排序所有的边（放在heap里），依次选择weight最小的边，如果加上边没有形成环，
    # 就加上，直到遍历完所有的边为止；判断环的方法：使用并查集结构，刚开始每个点是一个集合，两点相连之后进入同一个集合，如果查询新边时：
    # 这条边的起点和终点已经在同一个集合里则加上这条边会形成环
    # (就是说加入这条边之前，两个点已经通过某些边相连了，加了额外的边就会形成环)
    # Prim算法，要求无向图，生成最小生成树；创一个空集合记录已经联通的点们，创一个minheap来方便找权重最小的边，图中随便选一个点fromNode，
    # 所有从这个点出发的边先扔到heap里然后pop出找权重最小的那个(找到了一条结果边)连到toNode, 确定toNode不在联通集合中，toNode为找到的新点，
    # 然后把从toNode出发的所有边放到heap里，循环直至heap为空且所有点遍历完，则所有找到的边为min span tree
    # p 和 k 算法的区别在于，k算法存在两个大集合合并的可能性，所以必须用并查集，p算法每次只引入一个新点，所以不一定需要并查集结构
    # Dijkstra算法，适用于边权重不为负的图，规定起点，返回从起点出发到各个点的最短距离。从起点出发，创一个起点到各个点距离的map，创一个不再改距
    # 离的点集合从map中返回要处理的从起点出发距离最小的点，找从这个点发散出去的边从而找到toNode，对每个toNode更新distancemap中的距离
    ############################################# 前缀树和贪心算法 #######################################################
    # Trie和Trie Node，看helper里面的实现就好了
    # 贪心算法：在某一个标准下，优先考虑最满足标准的样本，最后考虑不满足标准的样本，最终得到一个答案的算法
    # 贪心算法找的是局部最优解而不是整体最优解,需要准备一些暴力解的算法模板
    # 安排会议问题，leetcode435
    # 给一个字符串数组，返回最小字典序融合字符串 a+b <= b+a ? a+b : b+a
    # 哈夫曼编码问题，找分金子的最小代价
    # 求给定初始资金，给定project list，给定最多做几个project，最大的利润是多少
    ################################################### 堆的应用问题 #####################################################
    # 数据流中位数问题: 初始化一个maxheap一个minheap,第一个数进maxheap,从第二个数开始，如果cur <= maxheap堆顶，进maxheap，否则进minheap
    # 如果两个heap大小相差等于或超过2，从size更大的堆弹出一个元素放到另一个堆里
    # *** 手动改堆，要求实现一个功能，改堆中的某一个值，改完后调整整个堆使得他重新满足堆的结构性质， 目前的系统堆不支持这个功能
    ###################################################### N皇后问题 ####################################################
    # 一行一行找当前行皇后的位置，判断新行中的位置：不能和已有的皇后共线，最后返回皇后排法
    ###################################################### 暴力递归 #####################################################
    # 把问题转化为规模变小的子问题，找到明确的base case，根据子问题结果进行接下来的操作，不记录每个子问题的解
    # 汉诺塔问题： n: 1.先把 1~n-1从from移到other, 2. 把n从from移到to, 3.把1~n-1从other移到to
    # 打印一个字符串所有的子字符串（包括空）,即返回一个集合所有的子集合(包括空集合) 2^n复杂度
    ################################################ 基础提升 hash function, hash table #################################
    # f(in) = out, in 无穷， out有穷， MD5(0 ~ 2**64 - 1)/SHA1(0~ 2**128 - 1)/SHA256（0~2**256 - 1）
    # 相同的in返回相同的out，不同的in可能有相同的out(collision,发生概率低)，f(in) -> out, 值域均匀并离散
    # 大数据量(40亿个数（~32GB）)在小内存量(1GB)时，如何统计最高频数：分割file至一个file内存可以装下，设为M，然后处理每个数（利用iterator遍历），
    # f(num) % M，其中f为哈希函数，这样之后相同结果的数放到相同的file中保存，这样做之后可以保证:每个file中的数上述操作的值相同，
    # 而且相同的数一定在同一个file里, 一次处理一个file遍历每一个file，统计最高频数即可
    # hashtable实现：array+linkedlist, f(key) % N => index in array, where array[i] is a linkedlist if collision.如果链表
    # 太长（长度打破了之前设置的一个上限），就扩容原始array一倍（和array append的时候双倍扩容一样，这样append操作复杂度还是渐进常数），然后把
    # 操作变为f(size) % 2N,重新在长array里面存储
    # hashtable 在使用上而非理论上是常数复杂度
    # 布隆过滤器，大量数据(eg 100亿个url黑名单)，查找某个元素是否在名单中，爬虫去重etc,使用空间很小（可以放在memory里面），但是会有一定误报概
    # 率原本是黑名单里的误报成白的这种不会发生，而会发生原本是白名单里的误报成黑名单，即更加严格
    # 位图：bitarray,bitmap, bit[],每个格子1字节表示0或1, python包有bitarray
    # 给一个十进制数，拿到他二进制表示的第i位的0，1状态：(num >> i ) & 1
    # 给一个十进制数，把第i位的0，1状态变成1：num | (1 << i)
    # 给一个十进制数，把第i位的0，1状态变成0：num & (~(1 << i))
    # 过滤器原理：做一个M长度的位图，选K个hash function，遍历所有的url，每个url通过f_i(url) % M (i:1..K)来返回K个0~M-1的值，把位图中这
    # 些位置标1即可，查询时若一个被查url的每一位都是1，则在黑名单中。误报的概率主要依赖于M和K,M不能太小，K不能太大
    # P:误报率，M:bitmap 长度， n:一共多少个url: M=n*ln(P)/(ln(2) ** 2); K = ln2*M/n,向上取整；P_real = (1-exp(-n*K/M))^K
    # 一致性哈希原理：处理有逻辑层+数据层的应用，数据层是利用f(key)%N来进行数据分配的，负载均衡：若查询的数据存在频率的差距，这种算法可以保证
    # 不同查询频率下的数据均衡。这个东西的本质是hash function的值域中均匀分布的性质，选择什么当key:数据种类多的(id号码,名字)
    # 经典实现的弊端是，如果数据服务器需要扩充，迁移代价是全量的，需要重算所有的hash，然后%(N+1)
    # 一致性算法： eg： f=MD5 0~2**64-1,想像这个值域为环,可以把每个机器的识别码通过相同的哈希函数转成0~2**64-1上的数，结果就是所有机器对应
    # 的哈希值会均匀地插在环上，当有新数据进来后，只需要通过hash函数算一个值，放在顺时针先碰到的那个哈希值对应的机器里就行(记录一个各个机器的hash
    # 值array即可)，新加机器的时候就是在环上多个点，大部分的数据不需要重新hash，只需要动一部分机器即可。
    # 问题：1.机器少的时候不一定能均分 2.增加/减少机器时负载不均衡 -> 虚拟节点技术，每个机器不是只算1个hash value而是算很多个（假设1000个）
    # 这样环的每一段都是所有机器均分的情况，当增加新机器时，同样也算很多个hash value，以保证在环的任意一段均为所有机器均分，这样迁移的时候就可以
    # 近似保证均衡
    ############################################## 并查集 ###############################################################
    # 岛问题，每行遍历感染，递归找所有
    # 并行算法：多个cpu按列分块整个区域，各自找自己方块中的岛数量，并记录边界值对应的初始感染点，并行结束后，每个cpu的每个初始感染点记录的岛先
    # 进入并查集作为独立的集合，然后若两个集合有相邻的边界点则合并，最后并查集里独立集合的数量就是岛的数量
    ############################################## KMP算法 ##############################################################
    # str1, str2 str1里是否包含str2，并返回第一个匹配位置，要求o(N)时间复杂度实现 (str.find())
    # "ABC1234de" "1234" <- yes, "1234e" <- no
    # 比较容易想的算法是一个复杂度为O(N*M)的算法即从左往右遍历str1，每次向后找str2长度然后看是不是每个字符都可以match,
    # kmp也使用相同的逻辑，但有加速，利用一个信息数组K，即此字符前的子串们最长相等的前后缀长度(不能取整体)：
    # "abbabb" -> 3 因为"abb" == "abb" 而 "abba" != "babb"
    # 算法流程 str1: [zzzababtkababatkz], str2: [ababa]
    # 计算str2的k信息数组 [-1,0,0,1,2]
    # 当loop str1的指针来到3: ababt != ababa,两边最后一个字符不等,即str1[7]!=str2[-1]
    # kmp会根据k信息将比对位置从str2[-1]跳到str2[3], str1仍停留在str1[7],即下一次比较为str1[7]是否和str2[2]相等，由于K信息里包含最长
    # 相等的前后缀为2，此时等同于比较str1[5,6,7]和str2[2,3,4],由于K信息，str2[0,1]==str2[2,3]==str1[5,6],所以可以直接比较str1[7]与str2[2]
    # 要点1:利用前后缀相等跳过了前后缀这个部分的比较,要点2:保证str1中跳过的部分一定和str2不match
    # 要点3:如果str2没有相等的任何长度前后缀，或str1和str2没有任何相同部分的时候相对于原始算法kmp算法没有加速
    # 自己走一遍例子 str1: abbsabbtcabbsabbe, str2: abbsabbtcabbsabbw
    ############################################# Manacher算法 #########################################################
    # 一个str里O(N) 复杂度求最长的回文子串(子串要求连续)， 重要信息：每个位置的最长回文半径
    # 比较容易想的方法：为了处理偶数回文的情况，在原始列中每个字符之间（包含首尾）加上一个特殊字符，然后每个位置出发向两边找回文长度，之后每个原始
    # 字符对应位置的长度除以2向下取整就是最后的答案
    # 回文半径/直径：半径：包含中心字符的半径，直径：以某字符为中心整个回文的长 ->回文半径数组
    # 之前所有的扩充中到达的回文最右边界 int R
    # 获得更远边界R的时候的中心点 int C
    ##################################################### 滑动窗口 #######################################################
    # 移动平均，最大值，最小值，中位数等一系列问题，每次不是重复求窗口中数字的统计量而是通过新滑入窗口的值和滑出窗口的值来更改前一个位置的统计量的
    # 方法, leetcode 239
    # 需要维持一个单调队列monotonic queue结构,此结构使用deque实现以满足从左右push/pop均为O(1)时间，当结构超过滑动窗口的长度的时候从里面
    # 删掉元素同时增加元素
    # 单调栈结构：解决一个数组中每个位置元素左边/右边第一个比他大或小的元素位置和值问题，栈内元素需要单调排列，每次碰到违反单调性的元素准备入栈时，
    # 从当前栈弹出元素，弹出元素左右符合要求的元素分别为：弹出元素在栈中压着的元素以及准备进栈的元素
    # 例题：一个全是正数的数组，定义指标A为，数组最小值和数组累加和的乘积，求这个指标最大的子数组 ->转化为遍历数组，最小值定住为当前值，找最大的
    # 累加和序列的问题，即可以用到单调栈结构
    ########################################### 二叉树递归套路 ###########################################################
    # 前提：题目整体求解目标是S规则，则求解流程可以定成先获得以每个节点为头节点的子树在S规则下的答案，通过这些答案求解原问题的答案
    # 树形dp的一般思路，相左右树分别要信息，并组织这个信息返回上一层递归，最终求出答案
    # 叉树节点间最大距离问题：从节点a出发，每次可以向上或向下走，但每个点只能经过一次，到达节点b时路径上节点个数为a到b的距离，据此，每两个节点间
    # 都有距离，求整棵树上的最大距离。利用根节点是否参与分成两种情况，根节点不参与的情况，最大距离为左树，右树最大距离的更大值，若根节点参与，则
    # 最大距离为*左树高+右树高+1
    # Party的最大快乐值问题,员工信息定义如下,可以看作只有唯一根节点的多叉树，boss是根节点 // leetcode 337
    # class Employee:
    #     def __init__(self, happyness: int , suboridates:List):
    #         self.happness = happyness
    #         self.subordinates = suboridates
    # 公司举办party，希望整体快乐值最高，并遵循以下原则：如果一个员工来了，那么这个员工所有直接下级都不能来，整体快乐值为每一个来的人的快乐值累加
    ####################################################### Morris 遍历 #################################################
    # 一种遍历二叉树的方式，时O(N)，空O(1),利用树中闲置指针达到省空间的目的,如果要求过程中不能修改树的话这个方法就不能用 （线索二叉树）
    # 来到当前节点，当前节点有左树,找左树最右节点，a.此节点右指针指向空时，让此节点右指针指向当前节点（即找到当前节点的前驱节点），然后当前节点向
    # 左移动；b. 此节点右指针指向当前节点时，让其指向空，当前指针向右移动
    # 若当前节点没有左树，当前指针向右移动。当前节点为空时遍历结束
    # Morris改写前中后序遍历
    ###### 判断什么时候用什么方法：必须使用左右树信息整和的时候，需要用递归，否则可以用遍历
    ###### 大数据题目技巧， 利用词频统计找数字
    # 位图解决某一范围内数字出现情况，可以节省空间 （1byte=8bit）
    # 1).32位整型数范围为0~4294967295，手里有一个包含40亿个32位整型数的文件，只给1G内存找出所有没在文件出现的整型数；给3kb内存找到一个没出现过的
    # 整型数. 1G:创一个一共有2^32位bit信息的位图，需要2^32/8=512M,可以fit进1G内存中，之后遍历文件，出现过的数字在位图上标记，最后没有标记的
    # 就是没出现过的；3kb: 3kb = 3 * 1024 = 1.5*2^11,一个整数(32位整型=32bit/(8bit/Byte)=4Byte),4B则可以表示1.5*2^9个数，那么我们
    # 生成一个长度为512的整型数组（2^9方便每个整型数的最大频数相同），*每个位置可以统计2^32/2^9范围的数，遍历40亿个数按频数直方图的方法更新512
    # 长度的整型数组，则一定可以找到512个位置中某一个位置没有放满2^23个数，找到范围之后再分成512份，直到找到一个数为止
    # 2).海量搜索词汇(100亿个搜索词)中找到top100热词。先用哈希表分流到小文件中，因为哈希函数的性质同一个词一定会在同一个文件里，之后遍历每一个文件
    # 统计top100词频，二维堆：每个文件先对应频数做一个heap，最后初始化一个总heap，把每个小heap堆顶扔到总堆里，之后每次从总堆里弹一个数，找到是哪个小
    # 堆的顶，从小堆里弹出，并将这个小堆的新顶扔到总堆里，直到找到top100
    # 3).32位无符号整数，一共有40亿个，一共给1G内存，问怎么找到所有出现了两次的数（哈希分流，或使用一个位图的两个位表示数字出现的状态，
    # 如果出现两次，则为10，如果只出现了一次就是01，如果00就是没出现过，11则为出现两次以上）memory=2^32*2=2^33bit=2^33/8byte。或者使用
    # 两个位图也是一样的
    # 4).3)问题，只给10mb内存，怎么找中位数，跟区间统计思想一样
    # 4)+.10G 文件内均为无符号整形数，给5G/5M/5K内存，怎么排序并生成另一个文件 -> 1.（本质是桶排序）用全部内存构建小根堆，统计每个数的频数，
    # 以数作为排序标准，先看小根堆最大有几条记录，假设为r，则需要遍历文件2^32/r次，这等同于将无符号整数范围按记录大小分块，每块可以fit进内存，
    # 利用堆统计该范围每个数的词频之后就可以输出了，堆中为每个数字出现了几次，按数字从小到大排列。 2.（本质是堆排序）准备一个大根堆，根据内存空间
    # 大小来决定大根堆里记录数量的上限，假设为N，遍历整个file，当大根堆还没到N条记录时，若有新的记录就加进去，若到了N条记录，又有新记录了，就pop
    # 掉堆顶，然后加进去新记录，新记录的数字必须比堆顶小，有新记录加进去之后堆需要调整以满足性质，这样遍历一次可以找到文件中最小的N个数，并且可以
    # 根据记录数量做最终的排序，之后继续重复遍历，这次加进堆的条件除了之前的条件之外还需要大于上一次循环的最终堆顶，这样遍历几次之后就可以排好序
    #################################################### 暴力递归到动态规划 ###############################################
    # 递归尝试->记忆化搜索-?>严格表结构动态规划->严格表结构精装版,机器人走路问题, 组成target数字的最少硬币数
    # 动态规划一般方法:先确定可变参数有几个来决定用几维数组做表，接下来根据题意和边界条件做一个递归版本的解，接下来在递归中加入缓存表（这个缓存
    # 表本质上就是动态规划中的那个表），改出一个记忆化搜索的版本。最后根据记忆化搜索的版本，直接改成动态规划的版本会非常直观
    # 改一下ABgame和目标值最小硬币数的动态规划：ABGame：需要画一个图看一下，两张表按对角线顺序填值，互相依赖
    # 3维动态规划，马跳象棋棋盘, 走K步生存问题，找零问题（一步一步优化）
    # 基本套路：递归尝试暴力解决->（可不做：加缓存记忆化搜索） -> 根据依赖结构关系改严格有序表结构 ->表结构的进一步优化（eg：平行四边形不等式）
    # 基本原则：递归方法：可变参数尽量少，尽量为一维参数（eg:整数），以方便改动态规划表结构
    ##################################################### 有序表 ########################################################
    # 支持哈希表所有操作，增删改查，但是key是按照有序来组织的而并不是随机的
    # 有序表：红黑树，AVL树，SB树，BBST（平衡搜索二叉树）
    # 操作O(log（n）)时间复杂度，四个东西复杂度一样，只有比较小的常数时间的区别，实现原理不同
    # * 搜索二叉树增改查删实现一下： 增：从root开始小于往左移，大于往右移，等于加到本节点的数据结构中，查比某个值小的最大节点，或比这个值大的最小
    # 节点的方法同增，需要额外一个变量记录当前最符合条件的值然后不断更新这个值，删：需要变量记录当前节点的父节点，如果要删的节点没有孩子，直接删掉，
    # 父节点指向空；如果只有左或右孩子，让父节点继承自己的左或右子树；如果有左也有右孩子，需要找左树最右节点或右树最左节点然后调整删掉的节点和找到
    # 的节点
    # 何为具有平衡性的树：狭义平衡：左右树高度差不超过1，广义平衡：左右树规模接近（这个规模可以用不同指标度量，节点数量，高度或者其他的什么东西）
    # AVL是狭义上严格的平衡树
    # 树的左旋，右旋：头节点向左挪动为左旋，头节点向右挪动为右旋，左旋时：移动后头节点的左树不变，原头节点右孩子的左子树作为头节点的右子树；
    # 右旋时：移动后头节点的右树不变，源头节点左孩子的右子树作为头节点左子树
    # 搜索二叉树 ->带有左右旋操作的搜索二叉树 ->利用左右旋操作实现自平衡的搜索二叉树（AVL:树高度作为measure，红黑树， SB树）
    # AVL自平衡：增加时：从根部增加一个节点，按照比根节点大小判断从而左右移的位置将加进来的节点向下移动到合适的位置，然后从这个位置开始，对其每个父
    # 节点判断平衡性，如果不平衡就左右旋进行调整；删除时：从删掉的节点位置开始通过父节点往上一层一层判断是否平衡，不平衡的话就左旋右旋去调整；删除
    # 特殊情况：删掉的节点同时有左右孩子时，需要找一个节点替换当前删掉的节点，之后要从这个替换节点的父节点开始查平衡性
    # 平衡性调整：LL -> 左树右旋，RR->右树左旋, LR->左树右节点先左旋后右旋到头, RL:右树左节点先右旋后左旋到头
    # 红黑树，SB树：增删改查逻辑一样，检查平衡性时机一样，只有如何判断不平衡不一样
    # SB树实现：平衡性判断：每棵树的大小，不小于其兄弟的子树的大小，即每颗叔叔树的大小不小于其任何侄子树的大小,大小指这棵树节点的个数；同样有LL，
    # RR， LR，RL型不平衡，第一部调整和AVL一样，调整之后，需要看哪个节点的左右树相较之前发生了变化， 需要在这些节点上递归调用调整函数
    # LL: 当前节点T左孩子L的左子树A规模大于当前节点右子树R规模，调整方法是先让T右旋,由于T节点结构发生了变化，需要在T节点
    # 再递归调用调整函数（这个函数根据具体情况属于上面四个的哪一个来进行调整），由于L节点结构也发生了变化，需要在L上也调一次调整函数
    # 红黑树：每个节点不是红就是黑，根节点和最底层空节点必须是黑，任何两个红节点不能相邻（相邻指不为直接的父子节点），
    # 对任何一棵子树来说，从头部cur出发到叶节点的每条路径要求黑节点数量一样
    ###################################################### 跳表 #########################################################
    # 结构: key, value, nextnodes是一个arr，里面每个元素是一个跳表node， key需要是可以比较的数据结构（python里需要重载__lt__和__eq__）
    #
    # #
    ######################################################## 中级1 #####################################################
    # 打表法：入参出参均为一个整数，先写一个最笨的能work的方法，然后输出前100个结果找规律，按照规律优化代码。这是一种强行优化的方法， 复杂度可以
    # 直接降到 o(1)，两人博弈吃4的幂的草问题；用6和8凑钱问题
    # 预处理技巧: 把频繁查询的过程用一个额外数组记录下来，染色问题：RGRGR -> RGGGG或RRGGG，问最少染几个位置； 最大边长的由1组成四条边的正方形
    # 给[a, b]上随机整数生成器，求 [c, d]上随机整数生成器 -> 统一做出等概率0,1生成器然后利用二进制位来生成其他范围上的随机数
    # 卡特兰数应用: 一共N个节点，一共可以有多少种不同的二叉树结构 F(N) = F(0)*F(N-1) + F(1)*F(N-2) + ... + F(N-1)*F(0), N >=2, F(0)=1, F(1)=1
    # 通项为Combination(2n, n) / (n+1),考虑成在一个正方形边长为N的网格中，从左下角走到右上角，并且不越过对角线的走法数目
    # https://www.zhihu.com/question/28452491
    ######################################################## 中级2 ######################################################
    # 补括号问题
    # 两个整数集合，定义一个操作为从一个集合拿出一个数放在另一个集合中，这个操作导致两个集合的平均数都严格上升，给任意两个集合，问这种操作最多做几次
    # *空集合不符合条件因为没有元素了
    # 最长有效括号子列的长度问题(DP, 每个位置代表以当前位置字符结尾的字串，最长有效括号长度是多长)
    # 把一个无序的栈里的元素变成栈内有序的，最多用一个额外栈结构
    # 在符合一定排列顺序的矩阵中找数字, eg, 每行有序，每列有序，或者每行0在左1在右（有个套路是从右上角往左下角找，可以把n2复杂度降到N级别）
    ######################################################### 中级4 #####################################################
    # 洗衣机问题：一个array n个元素，每个位置代表一个洗衣机里面的衣服，每次移动可以任选m个洗衣机，把每个被选中的洗衣机里的一件衣服同时放在当前洗衣机
    # 相邻的位置（可左可右），问多少轮后可以把状态变成每台洗衣机里面的衣服数量相等
    # 二维数组打印顺序： zigzag:找两个点，刚开始重合在左上角，每次两个点一个向右，一个向下，向下越界了就向右，向右越界了就向下, 然后操作是交替方向打印斜线，
    # 直到两个点再次重合就结束 螺旋和正方形旋转，考虑宏观调度而不是index的变化（一圈一圈来处理）
    # s="a", m="a", op1: m=s,s=s+s; op2: s=s+m => 给一个长度n，问最少要做几次操作（每次操作任选1或2）可以让s的长度变成n
    # 首先任何的质数只能用op2来实现（或者只能在第一步使用op1但是效果和op2一样），原因是op1实现的是： m=k*a, s=2*k*a,所以最后拼出来的s一定有一个质因数k,
    # 而质数只能被1和自己整除，所以只能通过op2把s累加到自己，否则会出现其他的质因数；其次如果n是合数，则先将n进行质因数分解，最后次数为单独凑出每个质因子
    # 次数的加和=>只需要对数字做一次质因数分解即可(leetcode650)
    ######################################################## 中级5 ######################################################
    # 最小栈问题：实现一个栈，在基本栈的功能基础上加上一个返回栈中最小值的操作：弄两个栈，第一个栈为原始栈，第二个栈和第一个栈同步压入值，每次压进
    # 去的新值小于第二个栈顶，则第二个栈顶压入新值，否则第二个栈重复压入栈顶
    # pop的时候两个栈也同时pop，这样就  可以保持第二个栈栈顶元素永远是当前栈中最小的
    # 只用栈，实现队列，弄两个栈，一个负责push一个负责pop，每次pop之前看pop栈是否为空，为空就把当前push栈里的东西倒进pop，然后弹出，不为空就
    # 直接弹出
    # 只用队列实现栈：弄两个队列，其中一个保持为空，另一个进数据，当需要弹出的时候把有数据的栈里面的n-1个元素弹出到另一个对列里然后返回最后一个值；
    # 进数据的时候永远进到那个不空的队列里
    # 动态规划二维表空间压缩技巧：当每个位置只依赖其左方和上方（或右方和下方）值时，二维表可以压缩成长度为原来表列数的一维数组
    # 接水问题：给一个arr，每个元素非负，整个数组构成的直方图为容器形状，问容器可以装多少的水，单独考虑每个位置左右两端的最大值，
    # 较小的那边和当前的高度决定当前位置可以装多少水，遍历这个arr把每个位置水量加起来
    # 就是最后的结果，可以初始化两个辅助数组计算每个点左和右的最值，也可以用有限个变量记录左右边界和最值，根据左右哪边的最值更小，可以从右往左或
    # 从左往右更新
    # 给定一个数组arr长度为N，你可以把他砍成两半，每一个部分必须含有元素，这样左右部分分别有各自的最大值，请返回最大的abs(l_max - r_max):
    # return max(arr) - min(arr[0], arr[-1])
    # string旋转词问题，把string复制一份放在后面，任何旋转词一定是这个长string的子string
    # 咖啡杯问题：arr[]每个元素为正，代表咖啡机效率，n代表多少人喝咖啡，每人喝一杯；a代表唯一一台洗咖啡杯的机器洗一个杯子的时间；b咖啡杯不洗自然
    # 变干净需要的时间，问从第一个人泡咖啡开始到最后一个人
    # 的咖啡杯变干净需要的最短时间是多少 （还没听，太长了，之后专门找个时间听一下）
    ###################################################### 中级6 ########################################################
    # 达标字符串 "10"， "101", "110", "111"，字符串只用0和1组成，出现0的地方左边一定靠着1，给字符串长度N，返回达标字符串数量
    # 打表看出来是个斐波那契数列结束, F(i)代表第一位放置1，后面i位自由变换的情况下达标的数量，则N时调F(N-1)得到答案
    # F(0) = 1, F(1) = 2, F(2) = 3 =F(0) + F(1) ... 
    # 除第一项外有严格递归关系[没有条件转移的问题]的问题O(N) -> O(log(N)) -> 数字和矩阵快速幂问题
    # F(N) = F(N-1) + F(N-2) => (F3, F2) = (F2, F1) @ np.array([[1,1],[1,0]])
    # (Fn, Fn-1) = (F2, F1) @ np.array([[1,1],[1,0]])^(n-2)，可推广到任意阶递推式 (幂矩阵需要解一个线性方程组求出矩阵元素值)
    # This shit scales up quickly...
    # 兔子问题，第一年一只兔子，新生的兔子3年成熟，可以继续生兔子,一只兔子可以活5年，问N年时一共几只 F(N) = F(N-1) + F(N-3) - F(N-5)
    # N根木棍长度从1到N，去掉k个之后剩下的N-K根任意三根无法组成三角形，给任意N返回最小的k -> 还是斐波那契数列
    # 牛牛找工作问题： 收集每一种工作的难度和报酬，找的标准是在难度不超过自身能力的情况下找报酬最高的，给一个job类数组，每个元素里有报酬和难度，
    # 给一个能力值array，假设每个工作有无数个岗位，返回一个报酬数组代表每个能力值获得的报酬 ->sort：难度从小到大，如果难度一样，报酬从大到小排
    # 序，之后删掉难度增加但是报酬没增加的记录然后根据能力值查找
    ########################################################### 中级7 ###################################################
    # 搜索二叉树转化为双向链表并返回链表头节点：我能想到中序遍历，无脑的方法是先中序一遍形成一个有序列，然后创造链表，复杂度O(N);
    # 递归方法：使用递归套路,每一个info返回当前节点为根节点的子树，构成双向链表后，左边的头和右边的头（即最小值节点和最大值节点）
    # 找到二叉树里最大的搜索二叉子树（子树意味着选中一个头节点之后头下面所有的东西构成的树），并返回这个子树的节点个数:使用递归套路，
    # info返回当前节点为根节点子树是否为搜索二叉树，以及以此节点为根节点的子树的最大值和最小值，以及以当前节点为根的最大二叉搜索子树节点个数，
    # 每次判断：左树是否为搜索树，右树是否为搜索树，若左右均为搜索子树，则判断左边最大，当前节点，和右边最小的相对关系，满足搜索树条件则当前节点
    # info中子树节点个数更新为左+1+右，若任意一个不为子树则返回左右更大的节点数+1，若左右均非子树则返回1，代表只有当前根节点组成的二叉搜索树；
    # 如果要同时返回子树的根节点，则info中需要额外包含一个最大搜索二叉子树头节点给先序，中序遍历数列，返回后序遍历数列
    # maximumSubArray问题：用了一个反证法证明kadane算法找到的是最大累加和以及最长的子序列
    # 给一个矩阵，返回最大子矩阵累加和：使用maximumSubArray方法每次求一个压缩过列的数组（压缩意味着把同一列连续行的元素相加形成的一个一维数组）
    # [[1,2,3],
    #  [2,-1,5]]即求[1,2,3]和[3,1,8]这两个一维数组的最大子序列和
    ####################################################### 中级8 #######################################################
    # 路灯问题：给一个array，里面的元素是点或者x，点代表需要照亮的位置，x代表墙，点位置可以放灯，每个灯可以照到当前位置，前一个位置和后一个
    # 位置，问最少要多少盏灯：题目可以使用贪心策略，X不给灯，点的话放一个灯，然后检查下一个位置，如果越界了break，如果是X跳两步，如果是点则向后
    # 跳三步，这时在当前位置的下一个放灯，可以cover这三个位置
    # 一个二叉树每个节点值都唯一，给中序遍历和先序遍历数组，返回后序遍历数组:前序遍历头左右，中序遍历左头右，后序遍历左右头，根据对应关系先找到头
    # 然后分别在三个序列中找到左树和右树的范围去进行递归
    # 完全二叉树的节点个数(complete tree),每个点递归，0. 求深度，每个点的情况：1.右树最左节点深度到了整个的深度->左树全满，右树完全，递归右树
    # 2. 右树最左节点深度没到整个深度 -》右树全满，左树完全，递归左树，边界条件为如果一个点没有左树也没有右树返回1
    # 牛牛分工作问题
    ###################################################### 中级9 ########################################################
    # 数组长度为n，每个元素是在1~n之间的整数，其中有一些会重复有一些不出现，找到没出现的数，想想O(1)空间要怎么写 ->试图让i位置放数字i+1，
    # 放不了的话就说明没有这个数字
    # 打赏主播问题 -> 类似于简化版背包问题，可以写递归，但需要加额外的一些限制条件使得不陷入循环递归（这个递归版本已经写好了，动态规划抽时间改一下）
    # 活动和收益问题:給一堆具有前后顺序的活动，每个活动具有消耗的时间和活动收益，你可以从任意一个活动开始，根据依赖关系做到最后一个活动，（最后一个
    # 活动是固定的而且一定要做到）问给定我拥有的最大天数，返回我能获得的最大收益以及选择的活动 -> 从最后一个活动向前bfs，每一个活动代表一个node，
    # node里面存一张表，表的key是从当前点出发做到最后一个活动需要的天数，value为对应的累积收益，在bfs的过程中更新每个节点的这张表，
    # 之后合并所有的表，并删掉不合理的记录（删掉耗费天数高但收益低的记录），之后根据自己有的天数来选择这张大表里的对应活动 =>实现的时候：
    # 做成双向图而不是单向图保证可以从最后一个活动往前面bfs
    # 给一个只有0,1,|,&,^五种字符组成的字符串，给一个bool值，问字符串可以有多少种组合方式得到bool值
    # -> 等价于考虑在这个串中的每一个二元运算符左侧和右侧加小括号，问如果想要最后得到true或false一共多少种加法 -> 范围上的递归改动态规划
    # 字符串中没重复字符的最长子串 -> longestSubstringWithoutRepeatingChars
    # 编辑距离问题：给两个字符串str1和str2,给三个整数代表插入，删除，替换一个字符的代价，问把字符串str1编辑成str2的最小代价
    # 给一个全是小写字母的字符串str，删掉多余字符，使得每种字符只保留一个，并且最终字符串结果的字典序最小: acbc -> abc, dbcacbca -> dabc
    # 第一步建立词频表， 从左到右找到最靠右的位置，删掉这个位置左侧所有东西之后剩下的东西至少包含每个字符一次，记这个位置为i，
    # 选择从0到i这个范围上字典序最小的最左侧的字符记为K，位置为j,删掉j左侧所有东西，
    # 并删掉0-i中选中的字符K，得到一个新的字符串，之后重新进行这一波操作直到剩下的字符词频都是1为止
    # {a} = 1, {b} = 2, .. {z}=26, {ab}=27, {ac}=28 .. , 随意给一个长度小于16的升序子序列返回编号
    # f(N): 长度为N的子序列有多少个， g(char,N):总长度为N，并以char开头的子序列有多少个
    ################################################### 高级1 ###########################################################
    # 给一个数组，求如果排序后，相邻两个数最大的差值，要求时间复杂度O(N)，要求不能用非基于比较的排序 【复习一下桶排序的原理】
    # 给出N个数字 a_1, a_2到a_N,将其以这些数字为端点任意分割成K个部分，K不确定，问怎么分能使得每个小部分的数字xor和为0，且K最大
    # dp[...], dp[i]代表原数组从0...i位置子数组最优划分下最大有几个xor和为0的部分
    # case1: 如果arr[i]位置的值不属于最优划分下最后一个xor和为0的子数组，则dp[i] = dp[i-1]
    # case2：如果arr[i]位置的值属于最优划分下最后一个xor和为0的子数组，则dp[i] = dp[k] + 1, k为离i最近的xor cumsum和xorsump[i]相同的位
    # 置，这个东西用hashmap来记录，key为xorsum,value为上一个出现这个xorsum的位置
    ################################################### 高级2 ###########################################################
    # 背包问题变形：有n1+n2钟面值的硬币，其中n1种为普通币，可以取用无数次，后n2种为纪念币，只能取用1枚，问正好凑出m价值的凑法有多少种
    # 大流程：用n1种凑出0有a_0，n2种凑出m有b_0种, 用n1凑出1有a_1种，用n2凑出m-1有b_1种，...最后返回\sum_{i=1}^{n}(a_i * b_i)
    # 等同于一个01背包一个完全背包拼在一起
    # 两个从小到大的有序数组A, B, 想找出其中最大的K个数字，并要求使用尽量少的比较次数
    # 算法原型：两个长度相同的有序数组找上中位数：长度均为偶数时:先看各自中点位置的数，如果相等直接返回，这个数就是上中位数，否则，大的那个中点左半
    # 部分和小的中点的右半部分看作两个等长的有序数组递归找上中位数，子问题的结果就是最终大问题的结果;长度为奇数时：先看各自中点位置的数，如果相等
    # 直接返回，这个数就是上中位数，否则，大的那个数包含自己和自己序列中与自己大的数都有可能，以及小的那个数自己序列中前面剩下的数都有可能，
    # 这时比较大中点和小中点前面的数，如果大中点更大，返回大中点，否则删掉大中点，子问题变成第一种长度为偶数的情况，递归找到子问题的上中位数
    ################################################# 高级3 #############################################################
    # 约瑟夫环问题：先找到一个递推式，假设一共i个节点，数到m就杀死节点，杀死的节点下一个为新的1号节点，问当前存活的节点在上一轮的编号是多少
    # 老=(新+m-1) % i + 1
    ############################################### 高级4 ###############################################################
    # 有序表：Key按有序的方式组织起来的结构，实现：红黑树，跳表，AVL树，SB tree，时间复杂度上没有区别，有序表增删改查全是log(n)复杂度
    # python里有一个sortedcontainner包可以实现treemap和treeset
    # 大楼轮廓问题：给定一个N*3的矩阵matrix,对于每个长度为3的小数组arr,都表示一个大楼的三个数据，arr[0]表示大楼的左边界，arr[1]表示大楼的右边界，
    # arr[2]表示大楼的高度(一定大于0) 每座大楼的地基都在X轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组
    # 思路：通过每个点最大高度来构建轮廓线；每个大楼统计从哪个点增加了当前的楼高度和减少了当前楼高度，做两个有序dict，map1: k=高度，
    # v=高度出现的次数，增加时+1，减少时-1，先增加后减少若某高度的频率变为0就从map1里删掉高度，map2: k=当前坐标，v=当前坐标最大高度
    # 给一个数组arr，无序，但每个值都是正数，再给另一个正数target，求arr所有子数组中元素和相加为target的最长子数组长度，需要时间复杂度O(N),
    # 空间O(1)-> 两个指针的滑动窗口
    # 给一个数组arr，无序，每个值可能正负0，再给另一个正数target，求arr所有子数组中元素和相加为target的最长子数组长度，需要时间复杂度O(N),
    # 空间O(1)
    # 给一个数组arr，无序，每个值可能正负0，再给另一个正数target，求arr所有子数组中元素和相加小于等于target的最长子数组长度，需要时间复杂度
    # O(N),空间O(1)
    # ->: 创造两个辅助数组 minSum 和 minSumEnd, minSum[i]=从i位置出发的所有子数组中和最小的和，
    # minSumEnd[i]=取到minSum[i]的子数组的最右边界; 从右往左 minSum[i] = min(arr[i], arr[i]+minSum[i+1])
    # ->: 从0位置出发利用minSum和minSumEnd看最小sum可以扩展到哪里，若最小sum还没到target则从end位置出发看可以扩到哪里，
    # 直至找到最远的使得全体sum小于等于target，就找到了从0出发最远的子数组长度,
    # ->: 此时形成一个窗口0...end,接下来滑动窗口左端从1开始，此时和为sum-arr[0],接下来看sum-arr[0]+minSum[end+1]是不是能继续扩展，
    # 能扩就扩，不能就继续移动左边界。从每个新起点开始，只关心能不能让答案变得更长
    # 给定一个非负数组，每个值代表该位置上有几个铜板，a和b玩游戏，a先手，b后手，轮到某个人的时候他可以在某一个位置拿任意数量的铜板，但是不能不拿
    # （不能拿0个），谁先把铜板拿完谁获胜，a和b都绝顶聪明，问谁获胜
    # xor所有的元素，如果非0那么先手赢，否则后手赢 -> 组合博弈中的尼姆博弈问题，谁先面对异或和为0的状态谁输，从非0异或和状态一定可以转化为0异或
    # 和状态
    ##################################################### 高级5 #########################################################
    # excel 列号转数字和数字转列号问题
    # 伪K进制: 每一位还是代表K**0, K**1, K**2 分别有几个,但是每一位的数字取值范围是1到K而不是0到K-1,这种机制用于表达所有的正数
    # 2321 -> CKG: 2321 - 1 = 2320: K**0位=1, 2320 - 26 = 2294: K**1位=1, 2294 - 676 = 1618: K**2位=1，
    # 1618 < 26 * 26 * 26所以没有第四位
    # 1618-676*2 = 266: K**2位变成1+2=3，266 - 26 * 10 = 6: K**1位变为1+10=11，最后一位变为1+6=7， 所以得到CGK
    # 二叉树最大路径和问题，不能往上走只能往下走，之前写过一个maxPathInBinaryTree是允许往上走的，稍微改一下
    # 贪吃蛇问题：给定一个二维数组matrix,每个单元格是一个整数，有正有负，最开始的时候玩家操纵一条长度为0的蛇从矩阵最左侧任选一个单元格进入地图，
    # 蛇没只能够到达当前位置右上，右和右下相邻的单元格，蛇到达一个单元格后，自身长度可以瞬间加上当前单元格的值，任何情况下，蛇长度为负游戏结束，
    # 玩家可以在过程中把任意一个单元格的值变为相反数，只能变这一个单元格一次，蛇也可以选择停止并结束游戏问在游戏过程中蛇的长度最多能到多长
    # -> 用递归套路写 然后可改记忆化搜索
    # 给定一个字符串str，str表示一个公式，公式里可以有整数，加减乘除和左右括号，返回公式计算结果(假设给的str是正确的公式，负数必须用括号括起来，
    # 除非负数在公式一开头或括号一开头)给定两个字符串str1和str2，求两个字符串的最长公共字串（字串是连续的）dp[i][j]:str1字串必须以i结尾，
    # str2字串必须以j结尾时最长公共子串长度，且最长公共子串也必须以str1[i],str2[j]结尾
    # 根据dp含义，表中任何一个行列位置，只要str1[i]!=str2[j]则dp[i][j]为0，相等则只依赖dp[i-1][j-1]的值,整个表中最大值即为最长公共字串长
    # 给定两个字符串str1和str2，求两个字符串的最长公共子序列（子序列可以是不连续的）dp[i][j]:str1到达位置i时子序列，
    # str2到达j时子序列最长公共子序列长度，且最长公共子序列不一定以str1[i],str2[j]结尾
    # 看代码，这个跟子串的思路不太一样，dp的定义也有区别
    ################################################ 高级6 ##############################################################
    # 给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重，再给定一个正数limit,代表一艘船的载重，坐船规则是一艘船最多坐两个人，且体重和
    # 不能超过limit，返回同时让N个人渡河最少几艘船给定一个字符串str返回最长的回文子序列: -> 把原始串逆序，然后求原始串和逆序串的最长公共子序列
    # 即为最长回文子序列范围上尝试模型：讨论开头和结尾位置存在不存在的可能性来进行尝试。
    # 这个问题子问题:dp[i][j] = str[i...j]上最长回文子序列是多长,讨论开头和结尾的情况共四种：a.str[i...j]上最长回文子序列不以i开头不以j结尾,
    # b.str[i...j]上最长回文子序列以i开头不以j结尾
    # c.str[i...j]上最长回文子序列不以i开头以j结尾, d.str[i...j]上最长回文子序列以i开头以j结尾
    # a: dp[i][j] = dp[i+1][j-1], b: dp[i][j] = dp[i+1][j], c: dp[i][j] = dp[i][j-1], d: dp[i][j] = dp[i+1][j-1]+2,
    # 每个格子依赖自己下方，左方和左下方的格子，从右下角向左上角填或者从左上角向右下角填，
    # 选择abcd四种结果中最大的值
    # 其中对角线和两字符相邻的情况是base case，右上角为最终答案代表从0到len-1范围上最长回文子序列的长度
    # 给定一个字符串str，如果可以在str的任意位置添加字符，请返回在添加字符最少的情况下，让str整体都是回文字符串的其中一种结果
    # dp[i][j]=str[i...j]需要至少添加几个字符使得其变为回文，一般情况有三种: a.单独拿出str[i]位置文字考虑剩下的部分先变成回文，
    # 然后在最后添加str[i], dp[i][j] = dp[i+1][j] + 1
    # b.单独拿出str[j]位置文字考虑剩下的部分先变成回文，然后在最前面添加str[j], dp[i][j] = dp[i][j-1] + 1
    # c.str[i]==str[j],此时只需要保证str[i+1...j-1]部分为回文即可，dp[i][j] = dp[i+1][j-1] iif str[i]==str[j]
    # 选择abc中最小的结果， 找到这个值之后，从结果出发寻找如何添加这些字符，以原字符串的开头和结尾重新构建新字符串
    # 给定一个字符串str，返回把str全部切成回文子串最少需要分成几个部分
    # 给定一个字符串str，可以通过移除其中一部分来使之变为回文串，(移除0个或多个字符)，如果空串不被认为是回文串，
    # 问一共有多少种移除方法可以使str变为回文串？若串中移除的两个字符相同但是位置不同，则认为是两种不同的移除方案。
    # dp[i][j]: i...j范围上有多少种保留方案变为回文串。 1.以i开头以j结尾 2.不以i开头不以j结尾 3.不以i开头以j结尾 4.以i开头不以j结尾 
    # dp[i][j-1] 代表情况2和4两种情况的方案数和
    # dp[i+1][j] 代表情况2和3两种情况的方案数和
    # dp[i+1][j-1]代表情况2的方案数
    # 对于1，如果i和j位置字符不同，则没有1的方案可能性，若i和j位置相同，则可能方案是在dp[i+1][j-1]基础上最左最右均加上相同的字符，
    # 或者只保留i和j， 则这种情况为dp[i+1][j-1]+1,其中加的1代表只保留i和j，dp[i+1][j-1]代表以dp[i+1][j-1]基础上最左最右均加上相同的字符
    # dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] if str[i] != str[j] else dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
    # + (dp[i+1][j-1] + 1)
    #################################################### 高级7 ##########################################################
    # 在一个无序数组中求最小的第K个数
    # BFPRT算法:无随机严格O(N) f(arr, K)
    # 1. 五个数一组分组 2.求每5个数的中位数，构成数组marr，O(N) 3. f(marr, len(marr)/2) = X, 4.以X为分界做荷兰国旗问题 5.如果X hit到
    # 了第K小直接返回，否则剩余问题规模最大为0.7N
    # T(N) = T(0.7N) + T(N/5) + O(N) -> T(N)为严格的O(N)复杂度
    # 给定一个正数N，返回裂开这个数的方法数，裂开的每个数最小为1，假设N裂开成三个不同的数，要求第二个数不小于第一个数且第三个数不小于第二个数
    # 给定一颗二叉树的头节点head，已知所有的节点值都不一样，返回其中最大的且满足二叉搜索树条件的拓扑结构有几个节点。拓扑结构不是二叉搜索子树，只要
    # 能连起来都算和中级的那个最大搜索二叉子树节点类似，每个info提供以当前节点为头的树可以为整体结构贡献多少个满足BST的节点
    # 对每个点，要看其左树右边界每一个节点是不是小于当前节点，如果大于，则那个节点包含的所有贡献要在沿途的路径上删去，因为从这个点开始不满足BST
    # 条件了，同理也要看当前节点右树左边界每个点是不是大于当前节点，然后相应更新贡献，最后当前节点的贡献为左子节点贡献加右子节点贡献加1
    # 完美洗牌问题：给定一个长度为偶数的数组arr,长度记为2*N,前N个为左部分，后N个为右部分，arr可以表示为[L1, L2, ..., Ln, R1, R2,..., Rn]
    # 请将数组调整为[R1,L1,R2,L2,...,Rn,Ln]的样子 (最优解in-place)
    # 结论： 当整个数组长度为3**K-1时，所有环的触发点为最大为3**(K-1)的3的幂, N=26时，三个触发点为1，3，9
    # 小算法：整体交换数组的左右部分，[abcde12] -> [12abcde],左部分逆序，右部分逆序，整体逆序
    # 对于任意偶数L，找到3**K-1这个数列里面不超过数组长度的最大数P,然后先让P个元素循环调整，剩下的L-P个元素重复这个步骤，步骤中需要利用小算法
    # 整体挪动数组使得P个数满足[L1,L2...L_p/2, R1,R2...R_p/2]的顺序形成小问题
    # 利用完美洗牌算法的其他问题：给一个无序数组，希望调整完整个数组变为[a1,a2,a3,a4...an]并且 a1<=a2, a2>=a3,a3<=a4...交错大小符号
    ############################################### 高级8 ##############################################################
    # 判定一个由[a-z]字符组成的字符串和一个包含[a-z]，?和*通配符的字符串是否匹配，?匹配任意单一非空字符，*匹配任意多个字符包括0个字符，字符串长度不超过
    # 100。*的用法： 不能独立使用，a*可以匹配aaaa....任意长度的只含a的串(或空串，代表0个a)
    # dp[si][pi] -> s[i...]能否匹配p[j...]，每个位置有两种情况: pi+1是*和不是*,如果不是*则需要匹配或者?, 如果是*需要检查一个两个三个..的情况
    # 看山问题：给一个非负数组arr,每个元素代表一座山的高度，整个山群是环形的，如果A和B是同一座山，无法相互看见；如果A和B是不同的山并且在环中相邻
    # 认为可以互相看见；如果A和B是不同且不相邻的山，假设这两座山最小高度是min:1.如果A通过顺时针方向或者逆时针方向到B的途中没有比min高的山峰，
    # 认为可以互相看见，给一个不含重复值的arr，返回有多少对山峰可以互相看见
    # 给定一个整数型数组arr，其中可能有正数负数和0，求其中子数组的最大异或和
    # 打气球问题，给一个整型数组arr，每个位置代表一个气球，当你打爆某一个位置的气球时，你的得分是这个位置数字*这个位置左边第一个没爆的气球的数字*
    # 这个位置右边第一个没爆的气球的数字，任意一侧没气球认为那一侧乘以1,得分累加，问最大的得分是多少,这里动态规划的尝试方法是假设在一个范围上每个
    # 位置的气球最后打爆这样隐含台词其范围外左右的气球都还没打爆
    # 汉诺塔问题要求把所有的圆盘从最左边移到最右边的柱子上，给定一个整型数组arr，其中值只含有1，2和3，代表三个圆盘，1代表左，2代表中，3代表右
    # arr[i]的值代表第i+1个圆盘的位置，比如arr=[3,3,2,1]代表1号和2号盘在最右边，3号盘在中间，4号盘在最左边
    # 如果arr代表的状态是最优移动轨迹过程中出现的状态，返回是第几个状态，否则返回-1
    pass


if __name__ == "__main__":
    dailyCheck()

